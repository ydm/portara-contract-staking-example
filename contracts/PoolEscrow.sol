// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity 0.8.16;

import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import {AddressUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import {CountersUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import {IERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol";
import {IERC20MetadataUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";
import {IERC20PermitUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol";
import {IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import {IPoolEscrow} from "./IPoolEscrow.sol";

interface IERC20 is IERC20MetadataUpgradeable, IERC20PermitUpgradeable {}

contract PoolEscrow is
    IPoolEscrow,
    AccessControlUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable
{
    using AddressUpgradeable for address payable;
    using CountersUpgradeable for CountersUpgradeable.Counter;

    // Reserve some space in case we need to inherit additional
    // classes in the future.
    uint256[1024] private __gap;

    bytes32 public constant POOLER_ROLE = keccak256("PoolEscrow::POOLER_ROLE");
    bytes32 public constant REQUESTER_ROLE = keccak256("PoolEscrow::REQUESTER_ROLE");
    uint256 public constant HUNDRED_BP = 10000;

    // +-------------------------+
    // | Initializable constants |
    // +-------------------------+

    address public pool;
    address public stakedEthToken;
    address public rewardEthToken;

    // +--------------+
    // | Configurable |
    // +--------------+

    /**
     * @notice If the available balance is below this amount,
     * immediate payments will not be paid, and a withdrawal request
     * will be created instead.
     */
    uint256 public minImmediatePayment;

    /**
     * @notice The withdrawal fee is represented in base points.
     *
     *     1 ==   0.01%
     *   100 ==   1.00%
     * 10000 == 100.00%
     */
    uint256 public withdrawalFee;

    // +----------------+
    // | Contract state |
    // +----------------+

    /**
     * @dev Requests are identified by sequential numbers issued at
     * the time of the request.  This counter always holds the number
     * of the next request index.  It's private, but the contract
     * provides its current value via the `nextRequestIndex()`
     * function.
     */
    CountersUpgradeable.Counter private _counter;

    /**
     * @notice `numProcessedRequests` holds the number of processed
     * requests so far.  Since requests are sequential and indexed,
     * that means all requests with indices in the range
     * [0;numProcessedRequests) are eligible to be withdrawn.
     *
     * Withdrawal requests with an index >= `numProcessedRequests`
     * need to wait until additional funds become available and
     * `numProcessedRequests` is bumped.
     */
    uint256 public numProcessedRequests;

    /**
     * @notice The total amount of ETH requested for withdrawal.
     */
    uint256 public totalRequested;

    /**
     * @notice The total amount of ETH withdrawn and sent to clients.
     */
    uint256 public totalWithdrawn;

    /**
     * @notice Holds the total amount of fees that are generated by
     * the contract, but are still not collected.
     */
    uint256 public uncollectedFees;

    /**
     * @notice `requests` maps a ticket number to the respective
     * withdrawal request.  Entires get deleted on successful
     * withdrawals.
     */
    mapping(uint256 /* ticket */ => WithdrawalRequest) public requests;

    // +-----------+
    // | Modifiers |
    // +-----------+

    modifier onlyAdmin() {
        _checkRole(DEFAULT_ADMIN_ROLE);
        _;
    }

    modifier onlyPooler() {
        _checkRole(POOLER_ROLE);
        _;
    }

    modifier onlyRequester() {
        _checkRole(REQUESTER_ROLE);
        _;
    }

    // +--------+
    // | System |
    // +--------+

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address pool_,
        address stakedEthToken_,
        address rewardEthToken_
    ) external override initializer {
        // Call super constructors:
        //
        // Initializable has no constructor.
        // ContextUpgradeable has no constructor.
        __ERC165_init(); // Empty.
        __AccessControl_init(); // Empty.
        __Pausable_init();
        __ReentrancyGuard_init();

        // Check and assign addresses.
        require(pool_ != address(0), "invalid pool address");
        require(stakedEthToken_ != address(0), "invalid sETH address");
        require(rewardEthToken_ != address(0), "invalid rETH address");
        pool = pool_;
        stakedEthToken = stakedEthToken_;
        rewardEthToken = rewardEthToken_;

        // Since this is an upgradeable contract, let's set all
        // stateful variables to zero.
        minImmediatePayment = 0;
        withdrawalFee = 0;
        _counter.reset();
        numProcessedRequests = 0;
        totalRequested = 0;
        totalWithdrawn = 0;

        // Assign the admin role.
        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());

        // Initial configuration.
        setWithdrawalFee(0);
        setMinImmediatePayment(1 ether);
    }

    /**
     * @notice Collect the uncollected fees from the contract and
     * transfer them to the caller.
     *
     * @custom:emit FeesCollected
     */
    function collectFees() external override onlyAdmin {
        uint256 value = availableBalance();
        if (value > uncollectedFees) {
            value = uncollectedFees;
        }
        require(value > 0, "no uncollected fees or balance");
        uncollectedFees -= value;
        emit FeesCollected(value, uncollectedFees, _msgSender());
        payable(_msgSender()).sendValue(value);
    }

    /**
     * @notice Pause withdrawal requests (but not withdrawals).  This
     * function is meant to be used when adding new features to the
     * smart contract.
     */
    function pause() external override onlyAdmin {
        _pause();
    }

    function unpause() external override onlyAdmin {
        _unpause();
    }

    function grantRole(bytes32 role, address account) public virtual override {
        require(role != DEFAULT_ADMIN_ROLE, "cannot grant admin role");
        super.grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual override {
        require(role != DEFAULT_ADMIN_ROLE, "cannot revoke admin role");
        super.revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual override {
        require(role != DEFAULT_ADMIN_ROLE, "cannot renounce admin role");
        super.renounceRole(role, account);
    }

    function transferAdminRole(address account) external virtual override onlyAdmin {
        require(account != address(0), "invalid address");
        super.grantRole(DEFAULT_ADMIN_ROLE, account);
        super.renounceRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    /**
     * @custom:emit MinImmediatePaymentUpdated
     */
    function setMinImmediatePayment(uint256 value) public override onlyAdmin {
        if (minImmediatePayment != value) {
            emit MinImmediatePaymentUpdated(minImmediatePayment, value);
            minImmediatePayment = value;
        }
    }

    /**
     * @custom:revert If fee is out of [0;10000).
     *
     * @custom:emit WithdrawalFeeUpdated
     */
    function setWithdrawalFee(uint256 fee) public override onlyAdmin {
        require(fee < HUNDRED_BP, "fee out of [0;10000)");
        if (withdrawalFee != fee) {
            emit WithdrawalFeeUpdated(withdrawalFee, fee);
            withdrawalFee = fee;
        }
    }

    /**
     * @notice Combines `permitTransfers()` and `requestFrom()`.
     */
    // prettier-ignore
    function permitRequestFrom(
        address owner,
        uint deadline,
        uint8 sv, bytes32 sr, bytes32 ss,
        uint8 rv, bytes32 rr, bytes32 rs,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount
    ) external override onlyRequester {
        permitTransfers(owner, deadline, sv, sr, ss, rv, rr, rs);
        _requestFrom(owner, stakedEthAmount, rewardEthAmount);
    }

    /**
     * @notice Enables contract administration to make withdrawal
     * requests on behalf of clients and pay for the gas instead of
     * them.
     */
    function requestFrom(
        address beneficiary,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount
    ) external override onlyRequester {
        _requestFrom(beneficiary, stakedEthAmount, rewardEthAmount);
    }

    function restake(uint256 value) external override onlyPooler {
        require(value <= availableBalance(), "balance not enough to restake");
        emit Restaked(value, _msgSender());
        payable(pool).sendValue(value); // Calls Pool.stake().
    }

    function restakeAll() external override onlyPooler {
        uint256 value = availableBalance();
        emit Restaked(value, _msgSender());
        payable(pool).sendValue(value); // Calls Pool.stake().
    }

    // +--------+
    // | Public |
    // +--------+

    /**
     * @notice `processRequest` unlocks withdrawal requests up to the
     * given number of processed requests, i.e. in the range
     * [0;newNPR).
     *
     * See `numProcessedRequests` for more information on that.
     *
     * @custom:revert If `newNPR` is out of the expected bounds.
     * @custom:revert If `newNPR` is in bounds, but available balance
     *                doesn't cover all pending withdrawal requests.
     *
     * @custom:emit RequestsProcessed
     */
    function processRequests(uint256 newNPR) external payable override whenNotPaused {
        // Check request number validity.
        uint256 boundary = nextRequestIndex();
        require(
            numProcessedRequests < newNPR && newNPR <= boundary,
            "newNPR out of expected bounds"
        );

        // We expect the current balance to cover all pending
        // withdrawals in the range [0;newNPR).
        //
        // To verify this, first we retrieve the latest request entry
        // that should be covered.  We know one exists for sure
        // because:
        //
        // 1. `numProcessedRequests` is initialized at 0, and since
        //    `numProcessedRequests` < `newNPR`, we have `newNPR` >= 1.
        //
        // 2. `newNPR` is <= `nextRequestIndex()`, so (`newNPR` - 1)
        //    is a valid request index,
        //
        // 3. The request at index `newNpr`-1 is definitely not
        //    withdrawn yet, as it hasn't been marked as processed.
        //
        // Once we have the latest expected-to-be-covered request, we
        // check the total amount of ETH requested to be withdrawn at
        // the time the request was created.  We expect the
        // `entry.totalRequested` amount to be fully covered by the
        // `totalWithdrawn` + the current contract balance, which
        // represents the total amount of ETH processed and either
        // already withdrawn or prepared for withdrawal by clients.
        WithdrawalRequest storage entry = requests[newNPR - 1];
        require(entry.beneficiary != address(0), "broken invariant");

        uint256 total = totalWithdrawn + address(this).balance;
        require(entry.totalRequested <= total, "balance not enough to cover");

        // Update state and emit event.
        emit RequestsProcessed({
            value: msg.value,
            begin: numProcessedRequests,
            end: newNPR,
            sender: _msgSender()
        });
        numProcessedRequests = newNPR;
    }

    /**
     * @dev It should be made apparent in the public documentation
     * that funds sent by mistake are not retrievable.
     */
    receive() external payable override {}

    /**
     * @notice Max the allowance of this contract to spend owner's
     * sETH and rETH.
     *
     * Allowance is needed as the first thing requests do is transfer
     * out of the client's wallet the respective amounts of sETH and
     * rETH.
     *
     * @param owner Owner of sETH and rETH tokens who's about to max
     *              the spending allowance.
     * @param deadline The block number after which this signature is
     *                 considered expired.
     * @param sv, sr, ss Signature to be used with
     *                   StakedEthToken.permit().
     * @param rv, rr, rs Signature to be used with
     *                   RewardEthToken.permit().
     */
    // prettier-ignore
    function permitTransfers(
        address owner,
        uint deadline,
        uint8 sv, bytes32 sr, bytes32 ss,
        uint8 rv, bytes32 rr, bytes32 rs
    ) public override {
        IERC20(stakedEthToken).permit(
            owner, address(this), type(uint256).max, deadline,
            sv, sr, ss
        );
        IERC20(rewardEthToken).permit(
            owner, address(this), type(uint256).max, deadline,
            rv, rr, rs
        );
    }

    /**
     * @notice Make a withdrawal request.
     */
    function request(uint256 stakedEthAmount, uint256 rewardEthAmount) external override {
        _requestFrom(_msgSender(), stakedEthAmount, rewardEthAmount);
    }

    /**
     * @notice Once a withdrawal request is fully processed, the
     * client (who initially submitted the request by providing their
     * stakedETH and rewardETH) can withdraw the respective ETH funds.
     *
     * @param requestIndex Index of the processed request to withdraw.
     *
     * @custom:revert If reentrancy is detected.
     * @custom:revert If not called by the beneficiary himself.
     * @custom:revert If current balance is insufficient.
     *
     * @custom:emit WithdrawalCompleted
     */
    function withdraw(uint256 requestIndex) external override whenNotPaused nonReentrant {
        require(requestIndex < numProcessedRequests, "request not yet processed");

        // Retrieve the withdrawal request and make sure it's valid.
        WithdrawalRequest memory entry = requests[requestIndex];

        // Since msg.sender is never empty, the following check also
        // ensures that the entry.beneficiary is not empty as well,
        // which in turn means that the ticket given is valid and
        // actually exists.
        require(_msgSender() == entry.beneficiary, "should be called by beneficiary");

        // Check the invariant.
        require(
            0 < entry.deferredPayment && entry.deferredPayment <= pending(),
            "broken invariant"
        );

        // Update the contract's state before sending ETH to protect
        // from potential re-entrancy vulnerabilities.
        totalWithdrawn += entry.deferredPayment;
        delete requests[requestIndex];

        // Emit an event.
        emit WithdrawalCompleted({
            requestIndex: requestIndex,
            deferredPayment: entry.deferredPayment,
            beneficiary: entry.beneficiary
        });

        // Finally, send the ETH.
        payable(entry.beneficiary).sendValue(entry.deferredPayment);
    }

    // +-------+
    // | Views |
    // +-------+

    /**
     * @notice How many withdrawal requests are there in the queue
     * waiting to be processed?
     */
    function queueSize() external view override returns (uint256) {
        return nextRequestIndex() - numProcessedRequests;
    }

    /**
     * @return The next available ticket number for a new withdrawal
     * request.
     */
    function nextRequestIndex() public view override returns (uint256) {
        return _counter.current();
    }

    function pending() public view override returns (uint256) {
        // The invariant expects `totalRequested` to always be >=
        // `totalWithdrawn`, but we do not have to check that
        // explicitly as an arithmetic underflow will occur in that
        // case.
        return totalRequested - totalWithdrawn;
    }

    /**
     * @notice How much ETH is immediately available?
     */
    function availableBalance() public view override returns (uint256) {
        uint256 balance = address(this).balance;
        uint256 owed = pending();

        if (balance > owed) {
            return balance - owed;
        }

        return 0;
    }

    /**
     * @dev Implements ERC-165, super.supportsInterface() comes from
     * AccessControlUpgradeable.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view override(IERC165Upgradeable, AccessControlUpgradeable) returns (bool) {
        return
            interfaceId == type(IPoolEscrow).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    // +---------+
    // | Private |
    // +---------+

    /**
     * @dev Create a new ticket and store it to contract's state for
     * later withdrawal once it's processed off-chain.
     *
     * @param beneficiary Client to pay to.
     * @param deferredPayment Amount to pay.
     */
    function _createRequest(
        address beneficiary,
        uint256 deferredPayment
    ) private returns (uint256) {
        // Create a new ticket number and update issuer.
        uint256 ticket = nextRequestIndex();
        _counter.increment();

        // Update pending withdrawals.
        totalRequested += deferredPayment;

        // Create a new request and store it under that ticket number.
        requests[ticket] = WithdrawalRequest({
            totalRequested: totalRequested,
            deferredPayment: deferredPayment,
            beneficiary: beneficiary
        });

        return ticket;
    }

    /**
     * @dev Request an immediate payment.
     *
     * @custom:revert If reentrancy is detected.
     * @custom:revert If current balance is insufficient.
     *
     * @param beneficiary Client to pay to.
     * @param stakedEthAmount sETH turned in on request.
     * @param rewardEthAmount rETH turned in on request.
     * @param net Net amount of ETH to pay to beneficiary.
     *
     * @custom:emit InstantWithdrawalCompleted
     */
    function _requestInstant(
        address beneficiary,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount,
        uint256 net
    ) private nonReentrant {
        emit InstantWithdrawalCompleted({
            stakedEthAmount: stakedEthAmount,
            rewardEthAmount: rewardEthAmount,
            immediatePayment: net,
            beneficiary: beneficiary
        });
        payable(beneficiary).sendValue(net);
    }

    /**
     * @dev Request a partial payment: send available amount right now
     * and create a ticket for the rest (net - available).
     *
     * @custom:revert If reentrancy is detected.
     * @custom:revert If current balance is insufficient.
     *
     * @param beneficiary Client to pay to.
     * @param stakedEthAmount sETH turned in on request.
     * @param rewardEthAmount rETH turned in on request.
     * @param net Net amount of ETH to pay to beneficiary.
     * @param available What's currently available and should be payed
     *                  right away.
     *
     * @custom:emit PartialWithdrawalRequested
     */
    function _requestPartial(
        address beneficiary,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount,
        uint256 net,
        uint256 available
    ) private nonReentrant {
        uint256 immediate = available;
        uint256 deferred = net - immediate;
        uint256 requestIndex = _createRequest(beneficiary, deferred);
        emit PartialWithdrawalRequested({
            requestIndex: requestIndex,
            stakedEthAmount: stakedEthAmount,
            rewardEthAmount: rewardEthAmount,
            immediatePayment: immediate,
            deferredPayment: deferred,
            pending: pending(),
            beneficiary: beneficiary
        });
        payable(beneficiary).sendValue(immediate);
    }

    /**
     * @dev Request a full payment by creating a ticket for the whole
     * amount.
     *
     * @custom:revert If reentrancy is detected.
     *
     * @param beneficiary Client to pay to.
     * @param stakedEthAmount sETH turned in on request.
     * @param rewardEthAmount rETH turned in on request.
     * @param net Net amount of ETH to pay to beneficiary.
     *
     * @custom:emit DeferredWithdrawalRequested
     */
    function _requestFull(
        address beneficiary,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount,
        uint256 net
    ) private {
        uint256 requestIndex = _createRequest(beneficiary, net);
        emit DeferredWithdrawalRequested({
            requestIndex: requestIndex,
            stakedEthAmount: stakedEthAmount,
            rewardEthAmount: rewardEthAmount,
            deferredPayment: net,
            pending: pending(),
            beneficiary: beneficiary
        });
    }

    /*
     * @dev Make a withdrawal request.
     *
     * @param beneficiary Address of the client making the request.
     * @param stakedEthAmount Amount of sETH to be withdrawn.
     * @param rewardEthAmount Amount of rETH to be withdrawn.
     *
     * @custom:revert If contract is currently paused.
     * @custom:revert If the client has not approved this contract to
     *                transfer sETH or rETH.
     * @custom:revert If the net amount of the requested funds is 0.
     *
     * @custom:emit At least one of:
     *        - StakedEthToken::Transfer
     *        - RewardEthToken::Transfer
     * @custom:emit One of:
     *        - PoolEscrow::InstantWithdrawalCompleted
     *        - PoolEscrow::PartialWithdrawalRequested
     *        - PoolEscrow::DeferredWithdrawalRequested
     */
    function _requestFrom(
        address beneficiary,
        uint256 stakedEthAmount,
        uint256 rewardEthAmount
    ) private whenNotPaused {
        // Transfer staked ETH and reward ETH first.
        if (stakedEthAmount > 0) {
            bool success = IERC20(stakedEthToken).transferFrom(
                beneficiary,
                address(this),
                stakedEthAmount
            );
            require(success, "sETH transfer failed");
        }
        if (rewardEthAmount > 0) {
            bool success = IERC20(rewardEthToken).transferFrom(
                beneficiary,
                address(this),
                rewardEthAmount
            );
            require(success, "rETH transfer failed");
        }

        // Compute the net payment.
        uint256 gross = stakedEthAmount + rewardEthAmount;
        uint256 fee = (withdrawalFee * gross) / HUNDRED_BP;
        uint256 net = gross - fee;
        require(net > 0, "cannot request to withdraw 0");

        // Now choose one of three options depending on the amount
        // requested and the amount available immediately.
        uint256 available = availableBalance();
        if (net <= available) {
            // Requested amount of ETH is fully available for
            // immediate withdrawal, send it right away.
            _requestInstant(beneficiary, stakedEthAmount, rewardEthAmount, net);
        } else if (available >= minImmediatePayment) {
            // Requested amount is greater than the available balance.
            // Also, the available balance covers the minimum amount
            // to withdraw partially.
            //
            // We send what's available right away and issue a ticket
            // for the rest.
            _requestPartial(beneficiary, stakedEthAmount, rewardEthAmount, net, available);
        } else {
            // Create a new ticket for the whole amount requested.
            _requestFull(beneficiary, stakedEthAmount, rewardEthAmount, net);
        }

        // Track the fee.
        uncollectedFees += fee;
    }
}
